(*
    until => executa o estado em que estÃ¡ e transiciona para outro estado
    unless => transiciona para outro estado e executa o novo estado
*)


node obstacle(dist: int) returns (obs: bool)
let 
	automaton
		state OBSTACLE do
			obs = true;
			unless (dist > 45) then NO_OBSTACLE
		state NO_OBSTACLE do
			obs = false;
			unless (dist <= 45) then OBSTACLE
	end
tel


node movement(obs_left, obs_right: bool) returns (direction: int)
let
	automaton
		state AHEAD do
			direction = 1;
			unless (obs_left & obs_right) then REVERSE
				| (obs_left & (not obs_right)) then TURN_RIGHT
				| ((not obs_left) & obs_right) then TURN_LEFT
		state TURN_LEFT do
			direction = 2;
			unless (obs_left & obs_right) then REVERSE
				| (obs_left & (not obs_right)) then TURN_RIGHT
				| ((not obs_left) & (not obs_right)) then AHEAD
		state TURN_RIGHT do
			direction = 3;
			unless (obs_left & obs_right) then REVERSE
				| ((not obs_left) & obs_right) then TURN_LEFT
				| ((not obs_left) & (not obs_right)) then AHEAD
		state REVERSE do
			direction = 4;
			unless ((not obs_left) & (not obs_right)) then AHEAD
				| ((not obs_left) & obs_right) then TURN_LEFT
				| (obs_left & (not obs_right)) then TURN_RIGHT
	end
tel

node dc(direction_layer_1, direction_layer_2: int) returns (equals: bool)
let
	automaton
		state EQUALS do
			equals = true;
			unless ((direction_layer_1 < direction_layer_2) or (direction_layer_1 > direction_layer_2)) then NOT_EQUALS
		state NOT_EQUALS do
			equals = false;
			unless not ((direction_layer_1 < direction_layer_2) & (direction_layer_2 > direction_layer_1)) then EQUALS
	end
tel


node controller(distance_left, distance_right, direction_layer_2: int) returns (obs_left, obs_right, equals_direction: bool; direction_layer_1: int)
contract
	var
		rule1: bool;
	let
		rule1 = true;
	tel
		enforce (rule1)
		with (cntrl_dir_left, cntrl_dir_right, cntrl_back: bool)
	let
		obs_left = inlined obstacle(distance_left);
		obs_right = inlined obstacle(distance_right);

		direction_layer_1 = inlined movement(obs_left, obs_right);
		equals_direction = inlined dc(direction_layer_1, direction_layer_2);
	tel
