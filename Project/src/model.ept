(*
    until => executa o estado em que estÃ¡ e transiciona para outro estado
    unless => transiciona para outro estado e executa o novo estado
*)


node obstacle(dist: int) returns (obs: bool)
let 
	automaton
		state OBSTACLE do
			obs = true;
			unless (dist > 45) then NO_OBSTACLE
		state NO_OBSTACLE do
			obs = false;
			unless (dist <= 45) then OBSTACLE
	end
tel


node movement(cntrl_dir_left, cntrl_dir_right, cntrl_dir_reverse, cntrl_dir_layer: bool; direction_layer_2: int) returns (direction: int)
let
	automaton
		state AHEAD do
			direction = 1;
			unless (not cntrl_dir_reverse) then REVERSE
				| ((not cntrl_dir_right) or ((direction_layer_2=3) & cntrl_dir_layer)) then TURN_RIGHT
				| ((not cntrl_dir_left) or ((direction_layer_2=2) & cntrl_dir_layer)) then TURN_LEFT
		state TURN_LEFT do
			direction = 2;
			unless ((not cntrl_dir_right) or ((direction_layer_2=3) & cntrl_dir_layer)) then TURN_RIGHT
				| (((not cntrl_dir_left) or (not (direction_layer_2=2))) & cntrl_dir_layer) then AHEAD
				| (not cntrl_dir_reverse) then REVERSE
		state TURN_RIGHT do
			direction = 3;
			unless ((not cntrl_dir_left) or ((direction_layer_2=2) & cntrl_dir_layer)) then TURN_LEFT
				| (((not cntrl_dir_left) or (not (direction_layer_2=3))) & cntrl_dir_layer) then AHEAD
				| (not cntrl_dir_reverse) then REVERSE
		state REVERSE do
			direction = 4;
			unless (cntrl_dir_reverse) then AHEAD
				| (cntrl_dir_left) then TURN_LEFT
				| (cntrl_dir_right) then TURN_RIGHT
	end
tel

node controller(distance_left, distance_right, direction_layer_2: int) returns (obs_left, obs_right: bool; direction_layer_1: int)
contract
	var
		rule1, rule2, rule3, rule4: bool;
	let
		rule1 = not (obs_left & obs_right) or (direction_layer_1=4);
		rule2 = not (obs_left & (not obs_right)) or (direction_layer_1=3);
		rule3 = not ((not obs_left) & obs_right) or (direction_layer_1=2);
		rule4 = not ((not obs_left) & (not obs_right)) or ((direction_layer_1>=1) & (direction_layer_1<4));
	tel
		enforce (rule4) & (rule1) & (rule2) & (rule3)
		with (cntrl_dir_layer, cntrl_dir_reverse, cntrl_dir_left, cntrl_dir_right: bool)
	let
		obs_left = inlined obstacle(distance_left);
		obs_right = inlined obstacle(distance_right);

		direction_layer_1 = inlined movement(cntrl_dir_left, cntrl_dir_right, cntrl_dir_reverse, cntrl_dir_layer, direction_layer_2);
	tel
