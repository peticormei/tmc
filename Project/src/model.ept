(*
    until => executa o estado em que estÃ¡ e transiciona para outro estado
    unless => transiciona para outro estado e executa o novo estado
*)


node obstacle(dist: int) returns (obs: bool)
let 
	automaton
		state OBSTACLE do
			obs = true;
			unless (dist > 45) then NO_OBSTACLE
		state NO_OBSTACLE do
			obs = false;
			unless (dist <= 45) then OBSTACLE
	end
tel


node movement(cntrl_dir_left, cntrl_dir_right, cntrl_dir_layer: bool; direction_layer_2: int) returns (direction: int)
let
	automaton
		state AHEAD do
			direction = 1;
			unless (cntrl_dir_left & cntrl_dir_right) then REVERSE
				| (cntrl_dir_right) then TURN_RIGHT
				| (cntrl_dir_left) then TURN_LEFT
		state TURN_LEFT do
			direction = 2;
			unless ((not cntrl_dir_left) & (not cntrl_dir_right)) then AHEAD
				| (not cntrl_dir_right) then TURN_RIGHT
				| (cntrl_dir_left & cntrl_dir_right) then REVERSE
		state TURN_RIGHT do
			direction = 3;
			unless ((not cntrl_dir_left) & (not cntrl_dir_right)) then AHEAD 
				| (not cntrl_dir_left) then TURN_LEFT
				| (cntrl_dir_left & cntrl_dir_right) then REVERSE
		state REVERSE do
			direction = 4;
			unless ((not cntrl_dir_left) & (not cntrl_dir_right)) then AHEAD
				| (not cntrl_dir_left) then TURN_LEFT
				| (not cntrl_dir_right) then TURN_RIGHT
	end
tel

node dc(direction_layer_1, direction_layer_2: int) returns (equals: bool)
let
	automaton
		state EQUALS do
			equals = true;
			unless ((direction_layer_1 < direction_layer_2) or (direction_layer_1 > direction_layer_2)) then NOT_EQUALS
		state NOT_EQUALS do
			equals = false;
			unless not ((direction_layer_1 < direction_layer_2) & (direction_layer_2 > direction_layer_1)) then EQUALS
	end
tel


node controller(distance_left, distance_right, direction_layer_2: int) returns (obs_left, obs_right: bool; direction_layer_1: int)
contract
	var
		rule1, rule2, rule3, rule4, rule5: bool;
	let
		rule1 = not (obs_left & obs_right) or (direction_layer_1=4);
		rule2 = not (obs_left & (not obs_right)) or (direction_layer_1=3);
		rule3 = not ((not obs_left) & obs_right) or (direction_layer_1=2);
		rule4 = not ((not obs_left) & (not obs_right)) or (direction_layer_1=1);
		rule5 = true;
	tel
		enforce (rule1) & (rule2) & (rule3) & (rule4)
		with (cntrl_dir_left, cntrl_dir_right, cntrl_dir_layer: bool)
	let
		obs_left = inlined obstacle(distance_left);
		obs_right = inlined obstacle(distance_right);

		direction_layer_1 = inlined movement(cntrl_dir_left, cntrl_dir_right, cntrl_dir_layer, direction_layer_2);
	tel
