node obstacle(dist: int) returns (obs: bool)
let 
	automaton
		state OBSTACLE do
			obs = true;
			unless (dist > 45) then NO_OBSTACLE
		state NO_OBSTACLE do
			obs = false;
			unless (dist <= 45) then OBSTACLE
	end
tel

node motor(c: bool) returns (mode, velocity: int)
let 
	automaton
		state FORWARD do
			mode = 1;
			velocity = 255;
			unless not c then BACKWARD
		state BACKWARD do
			mode = 2;
			velocity = 255;
			unless c then FORWARD
	end
tel

node movement(c_dir: bool; event_dir: int) returns (turning: bool)
let
	automaton
		state MOVING do
			turning = false;
			unless event_dir = 2 or not c_dir then TURNING
		state TURNING do
			turning = true;
			unless event_dir = 1 & c_dir then MOVING
	end
tel

node controller(distance, event_dir: int) returns (obs, turning: bool; motor1, motor2, vel1, vel2: int)
	contract
		var
			rule: bool;
		let
			rule = not obs & not turning or (turning & (motor1=1 & motor2=2));
		tel
			enforce rule
			with (c_dir, c_motor1, c_motor2: bool)
		let
			obs = inlined obstacle(distance);
			turning = inlined movement(c_dir, event_dir);
			(motor1, vel1) =  inlined motor(c_motor1);
			(motor2, vel2) =  inlined motor(c_motor2);
		tel